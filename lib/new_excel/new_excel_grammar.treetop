grammar NewExcelGrammar
  rule root
    formula / primitive
  end

  rule formula
    "=" s formula_body
    {
      def evaluate
        formula_body.evaluate
      end
    }
  end

  rule formula_body
    function /
    remote_cell_reference /
    local_cell_reference /
    primitive_cell_body
  end

  rule function
    function_name "(" args:function_arguments ")"
    {
      def evaluate
        fn = function_name.text_value
        evaluated_arguments = args.evaluate
        NewExcel::BuiltInFunctions.public_send(fn, *evaluated_arguments)
      end
    }
  end

  rule function_name
    ID
  end

  rule function_arguments
    head:function_argument remaining:(s "," s function_argument)*
    {
      def evaluate
        list = []
        list << head.evaluate
        remaining.elements[0].elements.each do |el|
          if el.respond_to?(:evaluate)
            list << el.evaluate
          end
        end
        list
      end
    }
  end

  rule function_argument
    function /
    remote_cell_reference /
    primitive
  end

  rule remote_cell_reference
    sheet:ID DOT cell:ID
    {
      def evaluate
       sheet_name = sheet.text_value.strip
       cell_name = cell.text_value.strip

       # NewExcel::Map.new(context.file_path)
       file_path = ::File.join($context_file_path, "#{sheet_name}.csv")
       NewExcel::Data.new(file_path, 'csv').evaluate(cell_name)
     end
    }
  end

  rule local_cell_reference
    ID
  end

  rule primitive_cell_body
    time / float / integer / string / date
  end

  rule primitive
    date / time / float / integer / text
  end

  rule date
    (([0-9] / "-" / ":" / " " / "/")+) &{ |s|
      val = input
      (val =~ /\d/ && (val =~ /\// || val =~ /\-/)) && !Chronic.parse(val, hours24: true, guess: :begin).nil?
    }
    {
      def evaluate
        Chronic.parse(text_value, hours24: true, guess: :begin)
      end
    }
  end

  rule time
    [0-9]+ (":" [0-9]+)+

    {
      def evaluate
        text_value
      end
    }
  end

  rule float
    i1:[0-9]+ DOT i2:[0-9]+
    {
      def evaluate
        Float(i1.text_value + "." + i2.text_value)
      end
    }
  end

  rule integer
    i:[0-9]+ &{|s| s[0].text_value =~ /^[0-9]+$/ } # wtf?
    {
      def evaluate
        Integer(i.text_value)
      end
    }
  end

  rule DOT
    "."
    {
      def evaluate
        text_value
      end
    }
  end

  rule ID
    [a-zA-Z\_]+
  end

  # see http://cjheath.github.io/treetop/pitfalls_and_advanced_techniques.html
  rule string
    '"' inner_part:('\"' / !'"' .)* '"'
    {
      def evaluate
        inner_part.text_value
      end
    }
  end

  rule text
    .+
    {
      def evaluate
        text_value
      end
    }
  end

  rule s
    S?
  end

  rule S
    [ \t]+
  end
end
